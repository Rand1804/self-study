# [Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html)

## Getting Started

Rust's implementation of async differs from most languages in a few ways:

- Futures are inert in Rust and make progress only when polled. Dropping a future stops it from making further progress.
- Async is zero-cost in Rust, which means that you only pay for what you use. Specifically, you can use async without heap allocations and dynamic dispatch, which is great for performance! This also lets you use async in constrained environments, such as embedded systems.
- No built-in runtime is provided by Rust. Instead, runtimes are provided by community maintained crates.
- Both single- and multithreaded runtimes are available in Rust, which have different strengths and weaknesses.

> In most traditional threaded applications, threads usually do consume heap memory. This is due to several factors:

> 1. **Thread Stack:** Every thread that is created requires its own separate stack space. This stack memory is allocated on the heap and its size can vary based on the thread requirements and system settings. Each thread's stack contains the local variables that are only visible to that particular thread.
> 2. **Thread Control Block (TCB):** The operating system maintains metadata for each thread in a structure known as the Thread Control Block. This data includes information like the thread ID, priority, and state (running, ready, blocked, etc.). The TCB is also stored on the heap.
> 3. **Dynamic dispatching:** In the context of your question, if an application uses dynamic dispatch (where the exact method to be called is determined at runtime), this could require heap allocations. These are often implemented through "virtual tables" or "vtables" that map a method call to the actual implementation at runtime.

> In the asynchronous version of the function described in your example, using `async`/`await` allows you to write asynchronous code that looks like synchronous code. The Rust async runtime manages all of the details for you.

> 1. **No separate thread stack:** Each async task does not require a separate stack. Instead, the state of the function is kept in a state machine generated by the compiler, and this state machine is stored in the heap memory once (at creation time of the future) and does not grow or shrink.
> 2. **Statically dispatched function calls:** With Rust's futures and async/await, the functions to be called are known at compile time (static dispatch), so there is no need for heap-allocated vtables.
> 3. **Efficient heap usage:** Though the state machine generated by async/await in Rust is stored on the heap, the memory allocation is typically more predictable and manageable compared to traditional threading. The memory usage tends to be more efficient because it's not allocating a large block of stack memory for each task.
> So, the claim "Additionally, all function calls are statically dispatched, and there are no heap allocations!" in your example should be understood in this nuanced way. It doesn't mean that there are no heap allocations at all, but rather that the allocations are more efficient and manageable compared to the traditional threading approach.


